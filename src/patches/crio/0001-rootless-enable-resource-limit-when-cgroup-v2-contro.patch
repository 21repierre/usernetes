From 1c408e08ec3854fa4478802c09f493cfdaad5691 Mon Sep 17 00:00:00 2001
From: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
Date: Mon, 1 Feb 2021 18:52:30 +0900
Subject: [PATCH] rootless: enable resource limit when cgroup v2 controllers
 are delegated

Requires systemd-delegated cgroupfs driver.
See Usernetes PR 210 for the actual usage.

Signed-off-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>
---
 server/rootless.go | 66 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 65 insertions(+), 1 deletion(-)

diff --git a/server/rootless.go b/server/rootless.go
index 39c65a90b..9fecebaf8 100644
--- a/server/rootless.go
+++ b/server/rootless.go
@@ -1,10 +1,14 @@
 package server
 
 import (
+	"io/ioutil"
+	"path/filepath"
 	"strings"
 
+	"github.com/opencontainers/runc/libcontainer/cgroups"
 	rspec "github.com/opencontainers/runtime-spec/specs-go"
 	"github.com/opencontainers/runtime-tools/generate"
+	"github.com/sirupsen/logrus"
 )
 
 func hasNetworkNamespace(config *rspec.Spec) bool {
@@ -17,7 +21,43 @@ func hasNetworkNamespace(config *rspec.Spec) bool {
 }
 
 func makeOCIConfigurationRootless(g *generate.Generator) {
-	g.Config.Linux.Resources = nil
+	// Resource limitations requires cgroup v2 delegation (https://rootlesscontaine.rs/getting-started/common/cgroup2/).
+	if r := g.Config.Linux.Resources; r != nil {
+		// cannot control device eBPF with rootless
+		r.Devices = nil
+		if r.Memory != nil || r.CPU != nil || r.Pids != nil || r.BlockIO != nil || r.Rdma != nil || r.HugepageLimits != nil {
+			v2Controllers := getAvailableV2Controllers()
+			if _, ok := v2Controllers["memory"]; !ok && r.Memory != nil {
+				logrus.Warn("rootless: cgroup v2 memory controller is not delegated. Discarding memory limit.")
+				r.Memory = nil
+			}
+			if _, ok := v2Controllers["cpu"]; !ok && r.CPU != nil {
+				logrus.Warn("rootless: cgroup v2 cpu controller is not delegated. Discarding cpu limit.")
+				r.CPU = nil
+			}
+			if _, ok := v2Controllers["cpuset"]; !ok && r.CPU != nil {
+				logrus.Warn("rootless: cgroup v2 cpuset controller is not delegated. Discarding cpuset limit.")
+				r.CPU.Cpus = ""
+				r.CPU.Mems = ""
+			}
+			if _, ok := v2Controllers["pids"]; !ok && r.Pids != nil {
+				logrus.Warn("rootless: cgroup v2 pids controller is not delegated. Discarding pids limit.")
+				r.Pids = nil
+			}
+			if _, ok := v2Controllers["io"]; !ok && r.BlockIO != nil {
+				logrus.Warn("rootless: cgroup v2 io controller is not delegated. Discarding block I/O limit.")
+				r.BlockIO = nil
+			}
+			if _, ok := v2Controllers["rdma"]; !ok && r.Rdma != nil {
+				logrus.Warn("rootless: cgroup v2 rdma controller is not delegated. Discarding RDMA limit.")
+				r.Rdma = nil
+			}
+			if _, ok := v2Controllers["hugetlb"]; !ok && r.HugepageLimits != nil {
+				logrus.Warn("rootless: cgroup v2 hugetlb controller is not delegated. Discarding RDMA limit.")
+				r.HugepageLimits = nil
+			}
+		}
+	}
 	g.Config.Process.OOMScoreAdj = nil
 	g.Config.Process.ApparmorProfile = ""
 
@@ -45,3 +85,27 @@ func makeOCIConfigurationRootless(g *generate.Generator) {
 
 	g.SetLinuxCgroupsPath("")
 }
+
+// getAvailableV2Controllers returns the entries in /sys/fs/cgroup/<SELF>/cgroup.controllers
+func getAvailableV2Controllers() map[string]struct{} {
+	procSelfCgroup, err := cgroups.ParseCgroupFile("/proc/self/cgroup")
+	if err != nil {
+		logrus.Error(err)
+		return nil
+	}
+	v2Group := procSelfCgroup[""]
+	if v2Group == "" {
+		return nil
+	}
+	controllersPath := filepath.Join("/sys/fs/cgroup", v2Group, "cgroup.controllers")
+	controllersBytes, err := ioutil.ReadFile(controllersPath)
+	if err != nil {
+		logrus.Error(err)
+		return nil
+	}
+	result := make(map[string]struct{})
+	for _, controller := range strings.Split(strings.TrimSpace(string(controllersBytes)), " ") {
+		result[controller] = struct{}{}
+	}
+	return result
+}
-- 
2.27.0

