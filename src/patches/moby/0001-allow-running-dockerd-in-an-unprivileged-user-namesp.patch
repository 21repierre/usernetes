From 751fb0333ffb8f475ab75aff3532862602cf5db6 Mon Sep 17 00:00:00 2001
From: Akihiro Suda <suda.akihiro@lab.ntt.co.jp>
Date: Mon, 15 Oct 2018 16:52:53 +0900
Subject: [PATCH] allow running `dockerd` in an unprivileged user namespace
 (rootless mode)

Please refer to `docs/rootless.md`.

TLDR:
 * Make sure `/etc/subuid` and `/etc/subgid` contain the entry for you
 * `dockerd-rootless.sh --experimental`
 * `docker -H unix://$XDG_RUNTIME_DIR/docker.sock run ...`

Signed-off-by: Akihiro Suda <suda.akihiro@lab.ntt.co.jp>
---
 Dockerfile                                    | 14 +++
 cli/config/configdir.go                       |  2 +
 cmd/dockerd/config_common_unix.go             | 21 +++++
 cmd/dockerd/config_unix.go                    |  4 +-
 cmd/dockerd/daemon.go                         | 43 +++++++--
 cmd/dockerd/daemon_unix.go                    | 24 ++++-
 cmd/dockerd/options.go                        |  2 +
 contrib/dockerd-rootless.sh                   | 69 +++++++++++++++
 daemon/config/config_unix.go                  |  6 ++
 daemon/config/config_windows.go               |  5 ++
 daemon/daemon.go                              |  1 +
 daemon/daemon_unix.go                         |  3 -
 daemon/info.go                                |  3 +
 daemon/info_unix.go                           |  4 +
 daemon/info_windows.go                        |  4 +
 daemon/listeners/listeners_linux.go           |  5 ++
 daemon/oci_linux.go                           |  9 +-
 docs/rootless.md                              | 88 +++++++++++++++++++
 hack/dockerfile/install/rootlesskit.installer | 34 +++++++
 hack/dockerfile/install/slirp4netns.installer | 28 ++++++
 hack/make/.binary-setup                       |  3 +
 hack/make/binary-daemon                       |  3 +-
 hack/make/install-binary                      |  3 +
 opts/hosts.go                                 | 22 ++++-
 opts/hosts_test.go                            |  4 +-
 pkg/homedir/homedir_linux.go                  | 88 +++++++++++++++++++
 pkg/homedir/homedir_others.go                 | 20 +++++
 pkg/sysinfo/sysinfo_linux.go                  |  4 +-
 rootless/doc.go                               |  2 +
 rootless/rootless.go                          | 22 +++++
 rootless/specconv/specconv_linux.go           | 38 ++++++++
 31 files changed, 559 insertions(+), 19 deletions(-)
 create mode 100755 contrib/dockerd-rootless.sh
 create mode 100644 docs/rootless.md
 create mode 100755 hack/dockerfile/install/rootlesskit.installer
 create mode 100755 hack/dockerfile/install/slirp4netns.installer
 create mode 100644 rootless/doc.go
 create mode 100644 rootless/rootless.go
 create mode 100644 rootless/specconv/specconv_linux.go

diff --git a/Dockerfile b/Dockerfile
index 53e761872e..fa83b1a993 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -161,7 +161,19 @@ ENV INSTALL_BINARY_NAME=tini
 COPY hack/dockerfile/install/$INSTALL_BINARY_NAME.installer ./
 RUN PREFIX=/build ./install.sh $INSTALL_BINARY_NAME
 
+FROM base AS rootlesskit
+ENV INSTALL_BINARY_NAME=rootlesskit
+COPY hack/dockerfile/install/install.sh ./install.sh
+COPY hack/dockerfile/install/$INSTALL_BINARY_NAME.installer ./
+RUN PREFIX=/build/ ./install.sh $INSTALL_BINARY_NAME
+COPY ./contrib/dockerd-rootless.sh /build
 
+FROM base AS slirp4netns
+RUN apt-get update && apt-get install -y automake autotools-dev libtool
+ENV INSTALL_BINARY_NAME=slirp4netns
+COPY hack/dockerfile/install/install.sh ./install.sh
+COPY hack/dockerfile/install/$INSTALL_BINARY_NAME.installer ./
+RUN PREFIX=/build/ ./install.sh $INSTALL_BINARY_NAME
 
 # TODO: Some of this is only really needed for testing, it would be nice to split this up
 FROM runtime-dev AS dev
@@ -227,6 +239,8 @@ RUN cd /docker-py \
 	&& pip install docker-pycreds==0.2.1 \
 	&& pip install yamllint==1.5.0 \
 	&& pip install -r test-requirements.txt
+COPY --from=rootlesskit /build/ /usr/local/bin/
+COPY --from=slirp4netns /build/ /usr/local/bin/
 
 ENV PATH=/usr/local/cli:$PATH
 ENV DOCKER_BUILDTAGS apparmor seccomp selinux
diff --git a/cli/config/configdir.go b/cli/config/configdir.go
index 4bef4e104d..f0b68ee387 100644
--- a/cli/config/configdir.go
+++ b/cli/config/configdir.go
@@ -13,6 +13,8 @@ var (
 )
 
 // Dir returns the path to the configuration directory as specified by the DOCKER_CONFIG environment variable.
+// If DOCKER_CONFIG is unset, Dir returns ~/.docker .
+// Dir ignores XDG_CONFIG_HOME (same as the docker client).
 // TODO: this was copied from cli/config/configfile and should be removed once cmd/dockerd moves
 func Dir() string {
 	return configDir
diff --git a/cmd/dockerd/config_common_unix.go b/cmd/dockerd/config_common_unix.go
index febf30ae9f..f876b4ec1a 100644
--- a/cmd/dockerd/config_common_unix.go
+++ b/cmd/dockerd/config_common_unix.go
@@ -3,9 +3,13 @@
 package main
 
 import (
+	"path/filepath"
+
 	"github.com/docker/docker/api/types"
 	"github.com/docker/docker/daemon/config"
 	"github.com/docker/docker/opts"
+	"github.com/docker/docker/pkg/homedir"
+	"github.com/docker/docker/rootless"
 	"github.com/spf13/pflag"
 )
 
@@ -15,6 +19,23 @@ var (
 	defaultExecRoot = "/var/run/docker"
 )
 
+func init() {
+	if !rootless.RunningWithNonRootUsername {
+		return
+	}
+	dataHome, err := homedir.GetDataHome()
+	if err != nil {
+		panic(err)
+	}
+	defaultDataRoot = filepath.Join(dataHome, "docker")
+	runtimeDir, err := homedir.GetRuntimeDir()
+	if err != nil {
+		panic(err)
+	}
+	defaultPidFile = filepath.Join(runtimeDir, "docker.pid")
+	defaultExecRoot = filepath.Join(runtimeDir, "docker")
+}
+
 // installUnixConfigFlags adds command-line options to the top-level flag parser for
 // the current process that are common across Unix platforms.
 func installUnixConfigFlags(conf *config.Config, flags *pflag.FlagSet) {
diff --git a/cmd/dockerd/config_unix.go b/cmd/dockerd/config_unix.go
index 2dbd84b1db..a730b81228 100644
--- a/cmd/dockerd/config_unix.go
+++ b/cmd/dockerd/config_unix.go
@@ -5,6 +5,7 @@ package main
 import (
 	"github.com/docker/docker/daemon/config"
 	"github.com/docker/docker/opts"
+	"github.com/docker/docker/rootless"
 	"github.com/docker/go-units"
 	"github.com/spf13/pflag"
 )
@@ -46,5 +47,6 @@ func installConfigFlags(conf *config.Config, flags *pflag.FlagSet) {
 	flags.BoolVar(&conf.NoNewPrivileges, "no-new-privileges", false, "Set no-new-privileges by default for new containers")
 	flags.StringVar(&conf.IpcMode, "default-ipc-mode", config.DefaultIpcMode, `Default mode for containers ipc ("shareable" | "private")`)
 	flags.Var(&conf.NetworkConfig.DefaultAddressPools, "default-address-pool", "Default address pools for node specific local networks")
-
+	// Mostly users don't need to set this flag explicitly.
+	flags.BoolVar(&conf.Rootless, "rootless", rootless.RunningWithNonRootUsername, "Enable rootless mode (experimental)")
 }
diff --git a/cmd/dockerd/daemon.go b/cmd/dockerd/daemon.go
index 0daf197270..6aeb08e428 100644
--- a/cmd/dockerd/daemon.go
+++ b/cmd/dockerd/daemon.go
@@ -40,12 +40,14 @@ import (
 	"github.com/docker/docker/libcontainerd/supervisor"
 	dopts "github.com/docker/docker/opts"
 	"github.com/docker/docker/pkg/authorization"
+	"github.com/docker/docker/pkg/homedir"
 	"github.com/docker/docker/pkg/jsonmessage"
 	"github.com/docker/docker/pkg/pidfile"
 	"github.com/docker/docker/pkg/plugingetter"
 	"github.com/docker/docker/pkg/signal"
 	"github.com/docker/docker/pkg/system"
 	"github.com/docker/docker/plugin"
+	"github.com/docker/docker/rootless"
 	"github.com/docker/docker/runconfig"
 	"github.com/docker/go-connections/tlsconfig"
 	swarmapi "github.com/docker/swarmkit/api"
@@ -98,6 +100,17 @@ func (cli *DaemonCli) start(opts *daemonOptions) (err error) {
 	if cli.Config.Experimental {
 		logrus.Warn("Running experimental build")
 	}
+	// return human-friendly error before creating files
+	if runtime.GOOS == "linux" && os.Geteuid() != 0 {
+		return fmt.Errorf("dockerd needs to be started with root. To see how to run dockerd in rootless mode with unprivileged user see the documentation (experimental)")
+	}
+	if cli.Config.IsRootless() {
+		logrus.Warn("Running in rootless mode (experimental). Cgroups, AppArmor, and CRIU are disabled.")
+		if !cli.Config.Experimental {
+			return fmt.Errorf("rootless mode is only supported when experimental is enabled")
+		}
+		// TODO: make sure mountns and netns are unshared.
+	}
 
 	system.InitLCOW(cli.Config.Experimental)
 
@@ -115,11 +128,14 @@ func (cli *DaemonCli) start(opts *daemonOptions) (err error) {
 		return err
 	}
 
+	potentiallyUnderRuntimeDir := []string{cli.Config.ExecRoot}
+
 	if cli.Pidfile != "" {
 		pf, err := pidfile.New(cli.Pidfile)
 		if err != nil {
 			return errors.Wrap(err, "failed to start daemon")
 		}
+		potentiallyUnderRuntimeDir = append(potentiallyUnderRuntimeDir, cli.Pidfile)
 		defer func() {
 			if err := pf.Remove(); err != nil {
 				logrus.Error(err)
@@ -127,6 +143,12 @@ func (cli *DaemonCli) start(opts *daemonOptions) (err error) {
 		}()
 	}
 
+	// Set sticky bit if XDG_RUNTIME_DIR is set && the file is actually under XDG_RUNTIME_DIR
+	if _, err := homedir.StickRuntimeDirContents(potentiallyUnderRuntimeDir); err != nil {
+		// StickRuntimeDirContents returns nil error if XDG_RUNTIME_DIR is just unset
+		logrus.WithError(err).Warn("cannot set sticky bit on files under XDG_RUNTIME_DIR")
+	}
+
 	serverConfig, err := newAPIServerConfig(cli)
 	if err != nil {
 		return errors.Wrap(err, "failed to create API server")
@@ -140,7 +162,8 @@ func (cli *DaemonCli) start(opts *daemonOptions) (err error) {
 
 	ctx, cancel := context.WithCancel(context.Background())
 	if cli.Config.ContainerdAddr == "" && runtime.GOOS != "windows" {
-		if !systemContainerdRunning() {
+		systemContainerdAddr, ok := systemContainerdRunning(cli.Config.IsRootless())
+		if !ok {
 			opts, err := cli.getContainerdDaemonOpts()
 			if err != nil {
 				cancel()
@@ -157,7 +180,7 @@ func (cli *DaemonCli) start(opts *daemonOptions) (err error) {
 			// Try to wait for containerd to shutdown
 			defer r.WaitTimeout(10 * time.Second)
 		} else {
-			cli.Config.ContainerdAddr = containerddefaults.DefaultAddress
+			cli.Config.ContainerdAddr = systemContainerdAddr
 		}
 	}
 	defer cancel()
@@ -585,7 +608,7 @@ func loadListeners(cli *DaemonCli, serverConfig *apiserver.Config) ([]string, er
 	var hosts []string
 	for i := 0; i < len(cli.Config.Hosts); i++ {
 		var err error
-		if cli.Config.Hosts[i], err = dopts.ParseHost(cli.Config.TLS, cli.Config.Hosts[i]); err != nil {
+		if cli.Config.Hosts[i], err = dopts.ParseHost(cli.Config.TLS, cli.Config.Hosts[i], rootless.RunningWithNonRootUsername); err != nil {
 			return nil, errors.Wrapf(err, "error parsing -H %s", cli.Config.Hosts[i])
 		}
 
@@ -662,9 +685,17 @@ func validateAuthzPlugins(requestedPlugins []string, pg plugingetter.PluginGette
 	return nil
 }
 
-func systemContainerdRunning() bool {
-	_, err := os.Lstat(containerddefaults.DefaultAddress)
-	return err == nil
+func systemContainerdRunning(isRootless bool) (string, bool) {
+	addr := containerddefaults.DefaultAddress
+	if isRootless {
+		if runtimeDir, err := homedir.GetRuntimeDir(); err == nil {
+			addr = filepath.Join(runtimeDir, "containerd", "containerd.sock")
+		} else {
+			return "", false
+		}
+	}
+	_, err := os.Lstat(addr)
+	return addr, err == nil
 }
 
 // configureDaemonLogs sets the logrus logging level and formatting
diff --git a/cmd/dockerd/daemon_unix.go b/cmd/dockerd/daemon_unix.go
index 7b03e28594..8b73951a77 100644
--- a/cmd/dockerd/daemon_unix.go
+++ b/cmd/dockerd/daemon_unix.go
@@ -15,11 +15,31 @@ import (
 	"github.com/docker/docker/daemon"
 	"github.com/docker/docker/daemon/config"
 	"github.com/docker/docker/libcontainerd/supervisor"
+	"github.com/docker/docker/pkg/homedir"
+	"github.com/docker/docker/rootless"
 	"github.com/docker/libnetwork/portallocator"
 	"golang.org/x/sys/unix"
 )
 
-const defaultDaemonConfigFile = "/etc/docker/daemon.json"
+var (
+	defaultDaemonConfigDir  = "/etc/docker"
+	defaultDaemonConfigFile = "/etc/docker/daemon.json"
+)
+
+func init() {
+	if !rootless.RunningWithNonRootUsername {
+		return
+	}
+	// NOTE: CLI uses ~/.docker while the daemon uses ~/.config/docker, because
+	// ~/.docker was not designed to store daemon configurations.
+	// In future, the daemon directory may be renamed to ~/.config/moby-engine (?).
+	configHome, err := homedir.GetConfigHome()
+	if err != nil {
+		panic(err)
+	}
+	defaultDaemonConfigDir = filepath.Join(configHome, "docker")
+	defaultDaemonConfigFile = filepath.Join(defaultDaemonConfigDir, "daemon.json")
+}
 
 // setDefaultUmask sets the umask to 0022 to avoid problems
 // caused by custom umask
@@ -34,7 +54,7 @@ func setDefaultUmask() error {
 }
 
 func getDaemonConfDir(_ string) string {
-	return "/etc/docker"
+	return defaultDaemonConfigDir
 }
 
 func (cli *DaemonCli) getPlatformContainerdDaemonOpts() ([]supervisor.DaemonOpt, error) {
diff --git a/cmd/dockerd/options.go b/cmd/dockerd/options.go
index cb5601a768..f6ea21a6dc 100644
--- a/cmd/dockerd/options.go
+++ b/cmd/dockerd/options.go
@@ -49,6 +49,8 @@ func newDaemonOptions(config *config.Config) *daemonOptions {
 // InstallFlags adds flags for the common options on the FlagSet
 func (o *daemonOptions) InstallFlags(flags *pflag.FlagSet) {
 	if dockerCertPath == "" {
+		// cliconfig.Dir returns $DOCKER_CONFIG or ~/.docker.
+		// cliconfig.Dir does not look up $XDG_CONFIG_HOME
 		dockerCertPath = cliconfig.Dir()
 	}
 
diff --git a/contrib/dockerd-rootless.sh b/contrib/dockerd-rootless.sh
new file mode 100755
index 0000000000..75ecc2e1b4
--- /dev/null
+++ b/contrib/dockerd-rootless.sh
@@ -0,0 +1,69 @@
+#!/bin/sh
+# dockerd-rootless.sh executes dockerd in rootless mode.
+#
+# Usage: dockerd-rootless.sh --experimental [DOCKERD_OPTIONS]
+# Currently, specifying --experimental is mandatory.
+#
+# /etc/subuid and /etc/subgid needs to be configured for the current user.
+# See the documentation for the further information.
+
+set -e -x
+if ! [ -w $XDG_RUNTIME_DIR ]; then
+	echo "XDG_RUNTIME_DIR needs to be set and writable"
+	exit 1
+fi
+if ! [ -w $HOME ]; then
+	echo "HOME needs to be set and writable"
+	exit 1
+fi
+
+rootlesskit=""
+for f in docker-rootlesskit rootlesskit; do
+	if which $f >/dev/null 2>&1; then
+		rootlesskit=$f
+		break
+	fi
+done
+if [ -z $rootlesskit ]; then
+	echo "rootlesskit needs to be installed"
+	exit 1
+fi
+
+slirp4netns=""
+for f in docker-slirp4netns slirp4netns; do
+	if which $f >/dev/null 2>&1; then
+		slirp4netns=$f
+		break
+	fi
+done
+if [ -z $slirp4netns ]; then
+	echo "slirp4netns needs to be installed"
+	exit 1
+fi
+
+if [ -z $_DOCKERD_ROOTLESS_CHILD ]; then
+	_DOCKERD_ROOTLESS_CHILD=1
+	export _DOCKERD_ROOTLESS_CHILD
+	# Re-exec the script via RootlessKit, so as to create unprivileged {user,mount,network} namespaces.
+	#
+	# --net specifies the network stack. slirp4netns and VPNKit are supported.
+	# Currently, slirp4netns is the fastest.
+	# See https://github.com/rootless-containers/rootlesskit for the benchmark result.
+	#
+	# --copy-up allows removing/creating files in the directories by creating tmpfs and symlinks
+	# * /etc: copy-up is required so as to prevent `/etc/resolv.conf` in the
+	#         namespace from being unexpectedly unmounted when `/etc/resolv.conf` is recreated on the host
+	#         (by either systemd-networkd or NetworkManager)
+	# * /run: copy-up is required so that we can create /run/docker (hardcoded for plugins) in our namespace
+	$rootlesskit \
+		--net=slirp4netns --slirp4netns-binary $slirp4netns --mtu=65520 \
+		--copy-up=/etc --copy-up=/run \
+		$DOCKERD_ROOTLESS_ROOTLESSKIT_FLAGS \
+		$0 $@
+else
+	[ $_DOCKERD_ROOTLESS_CHILD = 1 ]
+	# remove the symlinks for the existing files in the parent namespace if any,
+	# so that we can create our own files in our mount namespace.
+	rm -f /run/docker /run/xtables.lock
+	dockerd $@
+fi
diff --git a/daemon/config/config_unix.go b/daemon/config/config_unix.go
index 5ed6abd89e..2a31b874c1 100644
--- a/daemon/config/config_unix.go
+++ b/daemon/config/config_unix.go
@@ -39,6 +39,7 @@ type Config struct {
 	IpcMode              string                   `json:"default-ipc-mode,omitempty"`
 	// ResolvConf is the path to the configuration of the host resolver
 	ResolvConf string `json:"resolv-conf,omitempty"`
+	Rootless   bool   `json:"bool,omitempty"`
 }
 
 // BridgeConfig stores all the bridge driver specific
@@ -87,3 +88,8 @@ func verifyDefaultIpcMode(mode string) error {
 func (conf *Config) ValidatePlatformConfig() error {
 	return verifyDefaultIpcMode(conf.IpcMode)
 }
+
+// IsRootless returns conf.Rootless
+func (conf *Config) IsRootless() bool {
+	return conf.Rootless
+}
diff --git a/daemon/config/config_windows.go b/daemon/config/config_windows.go
index 0aa7d54bf2..47624fab46 100644
--- a/daemon/config/config_windows.go
+++ b/daemon/config/config_windows.go
@@ -55,3 +55,8 @@ func (conf *Config) IsSwarmCompatible() error {
 func (conf *Config) ValidatePlatformConfig() error {
 	return nil
 }
+
+// IsRootless returns conf.Rootless on Unix but false on Windows
+func (conf *Config) IsRootless() bool {
+	return false
+}
diff --git a/daemon/daemon.go b/daemon/daemon.go
index 651a57a139..428da80846 100644
--- a/daemon/daemon.go
+++ b/daemon/daemon.go
@@ -800,6 +800,7 @@ func NewDaemon(ctx context.Context, config *config.Config, pluginStore *plugin.S
 		logrus.Warnf("Failed to configure golang's threads limit: %v", err)
 	}
 
+	// ensureDefaultAppArmorProfile does nothing if apparmor is disabled
 	if err := ensureDefaultAppArmorProfile(); err != nil {
 		logrus.Errorf(err.Error())
 	}
diff --git a/daemon/daemon_unix.go b/daemon/daemon_unix.go
index 817025e93b..f4b18b3ca5 100644
--- a/daemon/daemon_unix.go
+++ b/daemon/daemon_unix.go
@@ -745,9 +745,6 @@ func verifyDaemonSettings(conf *config.Config) error {
 
 // checkSystem validates platform-specific requirements
 func checkSystem() error {
-	if os.Geteuid() != 0 {
-		return fmt.Errorf("The Docker daemon needs to be run as root")
-	}
 	return checkKernel()
 }
 
diff --git a/daemon/info.go b/daemon/info.go
index 5332ce1038..31f89efe96 100644
--- a/daemon/info.go
+++ b/daemon/info.go
@@ -174,6 +174,9 @@ func (daemon *Daemon) fillSecurityOptions(v *types.Info, sysInfo *sysinfo.SysInf
 	if rootIDs := daemon.idMapping.RootPair(); rootIDs.UID != 0 || rootIDs.GID != 0 {
 		securityOptions = append(securityOptions, "name=userns")
 	}
+	if daemon.configStoreRootless() {
+		securityOptions = append(securityOptions, "name=rootless")
+	}
 	v.SecurityOptions = securityOptions
 }
 
diff --git a/daemon/info_unix.go b/daemon/info_unix.go
index 6efdc16951..8fbeb2d07c 100644
--- a/daemon/info_unix.go
+++ b/daemon/info_unix.go
@@ -170,3 +170,7 @@ func parseInitVersion(v string) (types.Commit, error) {
 	}
 	return version, nil
 }
+
+func (daemon *Daemon) configStoreRootless() bool {
+	return daemon.configStore.Rootless
+}
diff --git a/daemon/info_windows.go b/daemon/info_windows.go
index 2c1ff460c3..62f5d46a6e 100644
--- a/daemon/info_windows.go
+++ b/daemon/info_windows.go
@@ -11,3 +11,7 @@ func (daemon *Daemon) fillPlatformInfo(v *types.Info, sysInfo *sysinfo.SysInfo)
 
 func fillDriverWarnings(v *types.Info) {
 }
+
+func (daemon *Daemon) configStoreRootless() bool {
+	return false
+}
diff --git a/daemon/listeners/listeners_linux.go b/daemon/listeners/listeners_linux.go
index c8956db258..9b5b3b7e77 100644
--- a/daemon/listeners/listeners_linux.go
+++ b/daemon/listeners/listeners_linux.go
@@ -8,6 +8,7 @@ import (
 	"strconv"
 
 	"github.com/coreos/go-systemd/activation"
+	"github.com/docker/docker/pkg/homedir"
 	"github.com/docker/go-connections/sockets"
 	"github.com/sirupsen/logrus"
 )
@@ -45,6 +46,10 @@ func Init(proto, addr, socketGroup string, tlsConfig *tls.Config) ([]net.Listene
 		if err != nil {
 			return nil, fmt.Errorf("can't create unix socket %s: %v", addr, err)
 		}
+		if _, err := homedir.StickRuntimeDirContents([]string{addr}); err != nil {
+			// StickRuntimeDirContents returns nil error if XDG_RUNTIME_DIR is just unset
+			logrus.WithError(err).Warnf("cannot set sticky bit on socket %s under XDG_RUNTIME_DIR", addr)
+		}
 		ls = append(ls, l)
 	default:
 		return nil, fmt.Errorf("invalid protocol format: %q", proto)
diff --git a/daemon/oci_linux.go b/daemon/oci_linux.go
index e330f4fc66..d4dbf2690b 100644
--- a/daemon/oci_linux.go
+++ b/daemon/oci_linux.go
@@ -16,10 +16,12 @@ import (
 	"github.com/docker/docker/oci"
 	"github.com/docker/docker/pkg/idtools"
 	"github.com/docker/docker/pkg/mount"
+	"github.com/docker/docker/rootless/specconv"
 	volumemounts "github.com/docker/docker/volume/mounts"
 	"github.com/opencontainers/runc/libcontainer/apparmor"
 	"github.com/opencontainers/runc/libcontainer/cgroups"
 	"github.com/opencontainers/runc/libcontainer/devices"
+	rsystem "github.com/opencontainers/runc/libcontainer/system"
 	"github.com/opencontainers/runc/libcontainer/user"
 	"github.com/opencontainers/runtime-spec/specs-go"
 	"github.com/pkg/errors"
@@ -88,7 +90,7 @@ func setDevices(s *specs.Spec, c *container.Container) error {
 	// Build lists of devices allowed and created within the container.
 	var devs []specs.LinuxDevice
 	devPermissions := s.Linux.Resources.Devices
-	if c.HostConfig.Privileged {
+	if c.HostConfig.Privileged && !rsystem.RunningInUserNS() {
 		hostDevices, err := devices.HostDevices()
 		if err != nil {
 			return err
@@ -862,6 +864,11 @@ func (daemon *Daemon) createSpec(c *container.Container) (retSpec *specs.Spec, e
 		s.Linux.ReadonlyPaths = c.HostConfig.ReadonlyPaths
 	}
 
+	if daemon.configStore.Rootless {
+		if err := specconv.ToRootless(&s); err != nil {
+			return nil, err
+		}
+	}
 	return &s, nil
 }
 
diff --git a/docs/rootless.md b/docs/rootless.md
new file mode 100644
index 0000000000..d4f833b044
--- /dev/null
+++ b/docs/rootless.md
@@ -0,0 +1,88 @@
+# Rootless mode (Experimental)
+
+The rootless mode allows running `dockerd` as an unprivileged user, using `user_namespaces(7)`, `mount_namespaces(7)`, `network_namespaces(7)`, and [slirp4netns](https://github.com/rootless-containers/slirp4netns).
+
+No SETUID/SETCAP binary is required except `newuidmap` and `newgidmap`.
+
+## Requirements
+* `newuidmap` and `newgidmap` need to be installed on the host. These commands are provided by the `uidmap` package on most distros.
+
+* `/etc/subuid` and `/etc/subgid` should contain >= 65536 sub-IDs. e.g. `penguin:231072:65536`.
+
+```console
+$ id -u
+1001
+$ whoami
+penguin
+$ grep ^$(whoami): /etc/subuid
+penguin:231072:65536
+$ grep ^$(whoami): /etc/subgid
+penguin:231072:65536
+```
+
+### Distribution-specific hint
+
+#### Debian (excluding Ubuntu)
+* `sudo sh -c "echo 1 > /proc/sys/kernel/unprivileged_userns_clone"` is required
+
+#### Arch Linux
+* `sudo sh -c "echo 1 > /proc/sys/kernel/unprivileged_userns_clone"` is required
+
+#### openSUSE
+* `sudo modprobe ip_tables iptable_mangle iptable_nat iptable_filter` is required. (This is likely to be required on other distros as well)
+
+#### RHEL/CentOS 7
+* `sudo sh -c "echo 28633 > /proc/sys/user/max_user_namespaces"` is required
+* [COPR package `vbatts/shadow-utils-newxidmap`](https://copr.fedorainfracloud.org/coprs/vbatts/shadow-utils-newxidmap/) needs to be installed
+
+## Restrictions
+
+* Only `vfs` graphdriver is supported. However, on [Ubuntu](http://kernel.ubuntu.com/git/ubuntu/ubuntu-artful.git/commit/fs/overlayfs?h=Ubuntu-4.13.0-25.29&id=0a414bdc3d01f3b61ed86cfe3ce8b63a9240eba7) and a few distros, `overlay2` and `overlay` are also supported. [Starting with Linux 4.18](https://www.phoronix.com/scan.php?page=news_item&px=Linux-4.18-FUSE), we will be also able to implement FUSE snapshotters.
+* Cgroups (including `docker top`) and AppArmor are disabled at the moment. In future, Cgroups will be optionally available when delegation permission is configured on the host.
+* Checkpoint is not supported at the moment.
+* Running rootless `dockerd` in rootless/rootful `dockerd` is also possible, but not fully tested.
+
+## Usage
+
+### Daemon
+
+You need to run `dockerd-rootless.sh` instead of `dockerd`.
+
+```console
+$ dockerd-rootless.sh --experimental"
+```
+As Rootless mode is experimental per se, currently you always need to run `dockerd-rootless.sh` with `--experimental`.
+
+Remarks:
+* The socket path is set to `$XDG_RUNTIME_DIR/docker.sock` by default. `$XDG_RUNTIME_DIR` is typically set to `/run/user/$UID`.
+* The data dir is set to `~/.local/share/docker` by default.
+* The exec dir is set to `$XDG_RUNTIME_DIR/docker` by default.
+* The daemon config dir is set to `~/.config/docker` (not `~/.docker`, which is used by the client) by default.
+* The `dockerd-rootless.sh` script executes `dockerd` in its own user, mount, and network namespace. You can enter the namespaces by running `nsenter -U --preserve-credentials -n -m -t $(cat $XDG_RUNTIME_DIR/docker.pid)`.
+
+### Client
+
+You can just use the upstream Docker client but you need to set the socket path explicitly.
+
+```console
+$ docker -H unix://$XDG_RUNTIME_DIR/docker.sock run -d nginx
+```
+
+### Exposing ports
+
+In addition to exposing container ports to the `dockerd` network namespace, you also need to expose the ports in the `dockerd` network namespace to the host network namespace.
+
+```console
+$ docker -H unix://$XDG_RUNTIME_DIR/docker.sock run -d -p 80:80 nginx
+$ socat -t -- TCP-LISTEN:8080,reuseaddr,fork EXEC:"nsenter -U -n -t $(cat $XDG_RUNTIME_DIR/docker.pid) socat -t -- STDIN TCP4\:127.0.0.1\:80"
+```
+
+In future, `dockerd` will be able to expose the ports automatically. See https://github.com/rootless-containers/rootlesskit/issues/14 .
+
+### Routing ping packets
+
+To route ping packets, you need to set up `net.ipv4.ping_group_range` properly as the root.
+
+```console
+$ sudo sh -c "echo 0   2147483647  > /proc/sys/net/ipv4/ping_group_range"
+```
diff --git a/hack/dockerfile/install/rootlesskit.installer b/hack/dockerfile/install/rootlesskit.installer
new file mode 100755
index 0000000000..3949eb950e
--- /dev/null
+++ b/hack/dockerfile/install/rootlesskit.installer
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+# v0.2.0
+ROOTLESSKIT_COMMIT=77cdbed39ff42bc96fb23830065ec2e28b7767e6
+
+install_rootlesskit() {
+	case "$1" in
+	"dynamic")
+		install_rootlesskit_dynamic
+		return
+		;;
+	"")
+		export CGO_ENABLED=0
+		_install_rootlesskit
+		;;
+	*)
+		echo 'Usage: $0 [dynamic]'
+		;;
+	esac
+}
+
+install_rootlesskit_dynamic() {
+	export ROOTLESSKIT_LDFLAGS="-linkmode=external" install_rootlesskit
+	export BUILD_MODE="-buildmode=pie"
+	_install_rootlesskit
+}
+
+_install_rootlesskit() {
+	echo "Install rootlesskit version $ROOTLESSKIT_COMMIT"
+	git clone https://github.com/rootless-containers/rootlesskit.git "$GOPATH/src/github.com/rootless-containers/rootlesskit"
+	cd "$GOPATH/src/github.com/rootless-containers/rootlesskit"
+	git checkout -q "$ROOTLESSKIT_COMMIT"
+	go build $BUILD_MODE -ldflags="$ROOTLESSKIT_LDFLAGS" -o "${PREFIX}/rootlesskit" github.com/rootless-containers/rootlesskit/cmd/rootlesskit
+}
diff --git a/hack/dockerfile/install/slirp4netns.installer b/hack/dockerfile/install/slirp4netns.installer
new file mode 100755
index 0000000000..249b15ef6c
--- /dev/null
+++ b/hack/dockerfile/install/slirp4netns.installer
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+# v0.2.0
+SLIRP4NETNS_COMMIT=4a59899d79285e9962550f171f73492171aae267
+install_slirp4netns() {
+	case "$1" in
+	"dynamic")
+		CONFIGURE_FLAGS=""
+		;;
+	"")
+		CONFIGURE_FLAGS="LDFLAGS=-static"
+		;;
+	*)
+		echo 'Usage: $0 [dynamic]'
+		;;
+	esac
+	echo "Install docker-slirp4netns version $SLIRP4NETNS_COMMIT"
+	git clone https://github.com/rootless-containers/slirp4netns.git "$GOPATH/src/github.com/rootless-containers/slirp4netns"
+	cd "$GOPATH/src/github.com/rootless-containers/slirp4netns"
+	git checkout -q "$SLIRP4NETNS_COMMIT"
+	./autogen.sh
+	./configure "$CONFIGURE_FLAGS"
+	make
+	mkdir -p "$PREFIX"
+	cp slirp4netns "${PREFIX}/slirp4netns"
+	# GPL v2
+	cp COPYING "${PREFIX}/slirp4netns.LICENSE"
+}
diff --git a/hack/make/.binary-setup b/hack/make/.binary-setup
index 69bb39b364..7553ef4244 100644
--- a/hack/make/.binary-setup
+++ b/hack/make/.binary-setup
@@ -7,3 +7,6 @@ DOCKER_CONTAINERD_CTR_BINARY_NAME='ctr'
 DOCKER_CONTAINERD_SHIM_BINARY_NAME='containerd-shim'
 DOCKER_PROXY_BINARY_NAME='docker-proxy'
 DOCKER_INIT_BINARY_NAME='docker-init'
+DOCKER_ROOTLESSKIT_BINARY_NAME='rootlesskit'
+DOCKER_SLIRP4NETNS_BINARY_NAME='slirp4netns'
+DOCKER_DAEMON_ROOTLESS_SH_BINARY_NAME='dockerd-rootless.sh'
diff --git a/hack/make/binary-daemon b/hack/make/binary-daemon
index 13c1d66c76..e89540ca60 100644
--- a/hack/make/binary-daemon
+++ b/hack/make/binary-daemon
@@ -14,12 +14,13 @@ copy_binaries() {
 		return
 	fi
 	echo "Copying nested executables into $dir"
-	for file in containerd containerd-shim ctr runc docker-init docker-proxy; do
+	for file in containerd containerd-shim ctr runc docker-init docker-proxy rootlesskit slirp4netns dockerd-rootless.sh; do
 		cp -f `which "$file"` "$dir/"
 		if [[ "$hash" == "hash" ]]; then
 			hash_files "$dir/$file"
 		fi
 	done
+	cp -f /usr/local/bin/slirp4netns.LICENSE "$dir/"
 }
 
 [[ -z "$KEEPDEST" ]] && rm -rf "$DEST"
diff --git a/hack/make/install-binary b/hack/make/install-binary
index 7a1af19b9c..9a7408a710 100644
--- a/hack/make/install-binary
+++ b/hack/make/install-binary
@@ -26,4 +26,7 @@ install_binary() {
 	install_binary "${DEST}/${DOCKER_CONTAINERD_SHIM_BINARY_NAME}"
 	install_binary "${DEST}/${DOCKER_PROXY_BINARY_NAME}"
 	install_binary "${DEST}/${DOCKER_INIT_BINARY_NAME}"
+	install_binary "${DEST}/${DOCKER_ROOTLESSKIT_BINARY_NAME}"
+	install_binary "${DEST}/${DOCKER_SLIRP4NETNS_BINARY_NAME}"
+	install_binary "${DEST}/${DOCKER_DAEMON_ROOTLESS_SH_BINARY_NAME}"
 )
diff --git a/opts/hosts.go b/opts/hosts.go
index 2adf4211d5..7e0744fb78 100644
--- a/opts/hosts.go
+++ b/opts/hosts.go
@@ -4,8 +4,11 @@ import (
 	"fmt"
 	"net"
 	"net/url"
+	"path/filepath"
 	"strconv"
 	"strings"
+
+	"github.com/docker/docker/pkg/homedir"
 )
 
 var (
@@ -18,6 +21,9 @@ var (
 	// DefaultUnixSocket Path for the unix socket.
 	// Docker daemon by default always listens on the default unix socket
 	DefaultUnixSocket = "/var/run/docker.sock"
+	// DefaultUserUnixSocket is set on init().
+	// Typically, the value will be "/run/user/$UID/docker.sock".
+	DefaultUserUnixSocket = DefaultUnixSocket
 	// DefaultTCPHost constant defines the default host string used by docker on Windows
 	DefaultTCPHost = fmt.Sprintf("tcp://%s:%d", DefaultHTTPHost, DefaultHTTPPort)
 	// DefaultTLSHost constant defines the default host string used by docker for TLS sockets
@@ -26,6 +32,14 @@ var (
 	DefaultNamedPipe = `//./pipe/docker_engine`
 )
 
+func init() {
+	runtimeDir, err := homedir.GetRuntimeDir()
+	if err == nil {
+		DefaultUserUnixSocket = filepath.Join(runtimeDir, "docker.sock")
+	}
+	// leave DefaultUserUnixSocket as-is if GetRuntimeDir returns non-nil error
+}
+
 // ValidateHost validates that the specified string is a valid host and returns it.
 func ValidateHost(val string) (string, error) {
 	host := strings.TrimSpace(val)
@@ -42,13 +56,17 @@ func ValidateHost(val string) (string, error) {
 }
 
 // ParseHost and set defaults for a Daemon host string
-func ParseHost(defaultToTLS bool, val string) (string, error) {
+func ParseHost(defaultToTLS bool, val string, rootlessMode bool) (string, error) {
 	host := strings.TrimSpace(val)
 	if host == "" {
 		if defaultToTLS {
 			host = DefaultTLSHost
 		} else {
-			host = DefaultHost
+			if rootlessMode {
+				host = "unix://" + DefaultUserUnixSocket
+			} else {
+				host = DefaultHost
+			}
 		}
 	} else {
 		var err error
diff --git a/opts/hosts_test.go b/opts/hosts_test.go
index e46326a5be..ec42a6c303 100644
--- a/opts/hosts_test.go
+++ b/opts/hosts_test.go
@@ -38,13 +38,13 @@ func TestParseHost(t *testing.T) {
 	}
 
 	for _, value := range invalid {
-		if _, err := ParseHost(false, value); err == nil {
+		if _, err := ParseHost(false, value, false); err == nil {
 			t.Errorf("Expected an error for %v, got [nil]", value)
 		}
 	}
 
 	for value, expected := range valid {
-		if actual, err := ParseHost(false, value); err != nil || actual != expected {
+		if actual, err := ParseHost(false, value, false); err != nil || actual != expected {
 			t.Errorf("Expected for %v [%v], got [%v, %v]", value, expected, actual, err)
 		}
 	}
diff --git a/pkg/homedir/homedir_linux.go b/pkg/homedir/homedir_linux.go
index ee15ed52b1..47ecd0c092 100644
--- a/pkg/homedir/homedir_linux.go
+++ b/pkg/homedir/homedir_linux.go
@@ -1,7 +1,10 @@
 package homedir // import "github.com/docker/docker/pkg/homedir"
 
 import (
+	"errors"
 	"os"
+	"path/filepath"
+	"strings"
 
 	"github.com/docker/docker/pkg/idtools"
 )
@@ -19,3 +22,88 @@ func GetStatic() (string, error) {
 	}
 	return usr.Home, nil
 }
+
+// GetRuntimeDir returns XDG_RUNTIME_DIR.
+// XDG_RUNTIME_DIR is typically configured via pam_systemd.
+// GetRuntimeDir returns non-nil error if XDG_RUNTIME_DIR is not set.
+//
+// See also https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
+func GetRuntimeDir() (string, error) {
+	if xdgRuntimeDir := os.Getenv("XDG_RUNTIME_DIR"); xdgRuntimeDir != "" {
+		return xdgRuntimeDir, nil
+	}
+	return "", errors.New("could not get XDG_RUNTIME_DIR")
+}
+
+// StickRuntimeDirContents sets the sticky bit on files that are under
+// XDG_RUNTIME_DIR, so that the files won't be periodically removed by the system.
+//
+// StickyRuntimeDir returns slice of sticked files.
+// StickyRuntimeDir returns nil error if XDG_RUNTIME_DIR is not set.
+//
+// See also https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
+func StickRuntimeDirContents(files []string) ([]string, error) {
+	runtimeDir, err := GetRuntimeDir()
+	if err != nil {
+		// ignore error if runtimeDir is empty
+		return nil, nil
+	}
+	runtimeDir, err = filepath.Abs(runtimeDir)
+	if err != nil {
+		return nil, err
+	}
+	var sticked []string
+	for _, f := range files {
+		f, err = filepath.Abs(f)
+		if err != nil {
+			return sticked, err
+		}
+		if strings.HasPrefix(f, runtimeDir+"/") {
+			if err = stick(f); err != nil {
+				return sticked, err
+			}
+			sticked = append(sticked, f)
+		}
+	}
+	return sticked, nil
+}
+
+func stick(f string) error {
+	st, err := os.Stat(f)
+	if err != nil {
+		return err
+	}
+	m := st.Mode()
+	m |= os.ModeSticky
+	return os.Chmod(f, m)
+}
+
+// GetDataHome returns XDG_DATA_HOME.
+// GetDataHome returns $HOME/.local/share and nil error if XDG_DATA_HOME is not set.
+//
+// See also https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
+func GetDataHome() (string, error) {
+	if xdgDataHome := os.Getenv("XDG_DATA_HOME"); xdgDataHome != "" {
+		return xdgDataHome, nil
+	}
+	home := os.Getenv("HOME")
+	if home == "" {
+		return "", errors.New("could not get either XDG_DATA_HOME or HOME")
+	}
+	return filepath.Join(home, ".local", "share"), nil
+}
+
+// GetConfigHome returns XDG_CONFIG_HOME.
+// GetConfigHome returns $HOME/.config and nil error if XDG_CONFIG_HOME is not set.
+//
+// See also https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
+func GetConfigHome() (string, error) {
+	if xdgConfigHome := os.Getenv("XDG_CONFIG_HOME"); xdgConfigHome != "" {
+		return xdgConfigHome, nil
+	}
+	home := os.Getenv("HOME")
+	if home == "" {
+		return "", errors.New("could not get either XDG_CONFIG_HOME or HOME")
+	}
+	return filepath.Join(home, ".config"), nil
+}
diff --git a/pkg/homedir/homedir_others.go b/pkg/homedir/homedir_others.go
index 75ada2fe54..f0a363dedf 100644
--- a/pkg/homedir/homedir_others.go
+++ b/pkg/homedir/homedir_others.go
@@ -11,3 +11,23 @@ import (
 func GetStatic() (string, error) {
 	return "", errors.New("homedir.GetStatic() is not supported on this system")
 }
+
+// GetRuntimeDir is unsupported on non-linux system.
+func GetRuntimeDir() (string, error) {
+	return "", errors.New("homedir.GetRuntimeDir() is not supported on this system")
+}
+
+// StickRuntimeDirContents is unsupported on non-linux system.
+func StickRuntimeDirContents(files []string) ([]string, error) {
+	return nil, errors.New("homedir.StickRuntimeDirContents() is not supported on this system")
+}
+
+// GetDataHome is unsupported on non-linux system.
+func GetDataHome() (string, error) {
+	return "", errors.New("homedir.GetDataHome() is not supported on this system")
+}
+
+// GetConfigHome is unsupported on non-linux system.
+func GetConfigHome() (string, error) {
+	return "", errors.New("homedir.GetConfigHome() is not supported on this system")
+}
diff --git a/pkg/sysinfo/sysinfo_linux.go b/pkg/sysinfo/sysinfo_linux.go
index 1fcf08310c..040c5a4dd6 100644
--- a/pkg/sysinfo/sysinfo_linux.go
+++ b/pkg/sysinfo/sysinfo_linux.go
@@ -51,7 +51,9 @@ func New(quiet bool) *SysInfo {
 
 	// Check if AppArmor is supported.
 	if _, err := os.Stat("/sys/kernel/security/apparmor"); !os.IsNotExist(err) {
-		sysInfo.AppArmor = true
+		if _, err := ioutil.ReadFile("/sys/kernel/security/apparmor/profiles"); err == nil {
+			sysInfo.AppArmor = true
+		}
 	}
 
 	// Check if Seccomp is supported, via CONFIG_SECCOMP.
diff --git a/rootless/doc.go b/rootless/doc.go
new file mode 100644
index 0000000000..f013e985b7
--- /dev/null
+++ b/rootless/doc.go
@@ -0,0 +1,2 @@
+// Package rootless provides spec converter
+package rootless
diff --git a/rootless/rootless.go b/rootless/rootless.go
new file mode 100644
index 0000000000..525d5c1610
--- /dev/null
+++ b/rootless/rootless.go
@@ -0,0 +1,22 @@
+package rootless
+
+import (
+	"os"
+)
+
+var (
+	// RunningWithNonRootUsername is set to true if we $USER is set to a non-root value.
+	// Note that this variable is set to true even when EUID is 0, typically when
+	// running in a user namespace.
+	//
+	// The value of this variable is mostly used for configuring default paths.
+	// If the value is true, $HOME and $XDG_RUNTIME_DIR should be honored for setting up the default paths.
+	// If false (not only EUID==0 but also $USER==root), $HOME and $XDG_RUNTIME_DIR should be ignored
+	// even if we are in a user namespace.
+	RunningWithNonRootUsername bool
+)
+
+func init() {
+	u := os.Getenv("USER")
+	RunningWithNonRootUsername = u != "" && u != "root"
+}
diff --git a/rootless/specconv/specconv_linux.go b/rootless/specconv/specconv_linux.go
new file mode 100644
index 0000000000..52f74b9457
--- /dev/null
+++ b/rootless/specconv/specconv_linux.go
@@ -0,0 +1,38 @@
+package specconv
+
+import (
+	"io/ioutil"
+	"strconv"
+
+	"github.com/opencontainers/runtime-spec/specs-go"
+)
+
+// ToRootless converts spec to be compatible with "rootless" runc.
+// * Remove cgroups (will be supported in separate PR when delegation permission is configured)
+// * Fix up OOMScoreAdj
+func ToRootless(spec *specs.Spec) error {
+	return toRootless(spec, getCurrentOOMScoreAdj())
+}
+
+func getCurrentOOMScoreAdj() int {
+	b, err := ioutil.ReadFile("/proc/self/oom_score_adj")
+	if err != nil {
+		return 0
+	}
+	i, err := strconv.Atoi(string(b))
+	if err != nil {
+		return 0
+	}
+	return i
+}
+
+func toRootless(spec *specs.Spec, currentOOMScoreAdj int) error {
+	// Remove cgroup settings.
+	spec.Linux.Resources = nil
+	spec.Linux.CgroupsPath = ""
+
+	if spec.Process.OOMScoreAdj != nil && *spec.Process.OOMScoreAdj < currentOOMScoreAdj {
+		*spec.Process.OOMScoreAdj = currentOOMScoreAdj
+	}
+	return nil
+}
-- 
2.17.1

